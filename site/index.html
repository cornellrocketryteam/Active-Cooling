<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Project Report</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" rel="stylesheet">
  <style>
    body {
      position: relative;
    }
    #sidebar {
      height: 100vh;
      position: fixed;
      top: 0;
      left: 0;
      padding-top: 2rem;
      background-color: #f8f9fa;
      border-right: 1px solid #dee2e6;
    }
    #main {
      margin-left: 220px;
      padding: 2rem;
    }
    .section {
      padding-top: 30px;
      margin-bottom: 30px;
    }
  </style>
</head>
<body data-bs-spy="scroll" data-bs-target="#sidebar" data-bs-offset="100" tabindex="0">

  <nav id="sidebar" class="position-fixed bg-light rounded border p-4" 
     style="top: 2rem; left: 2rem; width: 220px; max-height: 90vh; overflow-y: auto;">

  <h5 class="fw-bold mb-4">Sections</h5>
  <nav class="nav flex-column">
    <a class="nav-link text-primary fw-medium" href="#introduction">Introduction</a>
    <a class="nav-link text-primary fw-medium" href="#highlevel">High Level Design</a>
    <a class="nav-link text-primary fw-medium" href="#hardware">Hardware Design</a>
    <a class="nav-link text-primary fw-medium" href="#program">Program Design</a>
    <a class="nav-link text-primary fw-medium" href="#results">Results</a>
    <a class="nav-link text-primary fw-medium" href="#conclusions">Conclusions</a>
    <a class="nav-link text-primary fw-medium" href="#appendices">Appendices</a>
  </nav>
</nav>

    <!-- Main content -->
    <div id="main" class="flex-grow-1" style="margin-left: 270px; padding-top: 2rem;">
      <header class="mb-5">
        <!-- <h1>Active Cooling System</h1>
        <p class="lead">for high powered rocket infrastructure</p>
        <a class="btn btn-primary" href="#">
        <i class="fab fa-github me-1"></i> Source
      </a>
        <a class="btn btn-outline-primary" href="#">Demo</a>
        <p class="mt-3"><strong>Cameron Goddard, Nandita Nagarajan, Nissi Ragland</strong></p> -->

        <div class="card w-50 mb-3 bg-light">
          <div class="card-body">
            <h1 class="card-title fw-bold">Active Cooling System</h1>
            <p class="card-text fs-5 fw-normal mb-5">for high powered rocket infrastructure</p>
            <a class="btn btn-primary me-2" href="https://github.com/cornellrocketryteam/Active-Cooling">
              <i class="fab fa-github me-1"></i> GitHub
            </a>
            <a class="btn btn-primary" href="https://www.youtube.com/watch?v=kwYBSgyLhlI">
              <i class="fab fa-youtube me-1"></i> Demo
            </a>
        </div>
</div>

      </header>

      <section id="introduction" class="section">
        <h2>Introduction</h2>
        
        <p>
          The Active Cooling System (ACS) is an electronics cooling system controlled by a closed-loop controller through an iOS app that enables users to monitor and set temperatures. 
        </p>

        <p>
          We are members of the Cornell Rocketry Team, and part of our challenge is creating electrical systems that are able to withstand the environmental conditions of our launch sites. 
          This summer, we are launching in Midland, Texas, and we will have a box full of our ground support electronics right beside the launch pad for a few hours, exposed to extreme heat. Electronics, especially the Raspberry Pi 5 that acts as the computer for our ground support equipment, are particularly sensitive to high heat and can sometimes behave unexpectedly as a result. 
          We wanted to create an isolated system that could help maintain safe operating temperatures for our electronics, motivating us to develop the ACS. 
        </p>

        <p>
          The ACS utilizes an iPhone, Pico W, BME280 Temperature Sensor, and PWM Fans. This project aims to be as modular and intuitive as possible. As such, it relies on an iOS app to enable user control of the fans. Users can set a desired temperature for each fan and monitor the actual temperature readings from each sensor through a live graphic. 
          We created the hardware setup for these components on a breadboard, utilizing a typical DC outlet as our power source, such that it could easily fit into our existing ground support equipment architecture. We wrote a custom BME280 driver for the Pico to sample the sensor for temperature readings. Utilizing these temperature readings, 
          we use a proportional gain controller to adjust the PWM output of the fans, adjusting to cool the electronics according to a set desired temperature. The ACS combines these components to adjust fan speeds in a closed-loop controller, enabling user control of electronics temperatures.
        </p>
      </section>

      <section id="highlevel" class="section">
        <h2>High Level Design</h2>

        <h5 class="mt-5 mb-2">Rationale</h5>
          <p>
            This year, the Cornell Rocketry Team is launching our first-ever hybrid-powered rocket, which means our propulsion system consists of liquid oxidizer and solid propellant. This means that we require robust ground support equipment (GSE) right beside our rocket at the launchpad to remotely control fill operations of the tank on our rocket that holds the liquid oxidizer. 
            The GSE includes what we call the Fill Station, which contains a large box of electronics that routes signals sent from our control software to the relevant hardware, such that we can read sensor data and control valves in real-time. This box is subject to the environmental conditions of our launch sites. Our competition this summer is in an extremely hot desert in Midland, Texas, 
            so we needed a method for cooling these Fill Station electronics in an isolated, modular system that would easily fit into our electronics box and would not require human interaction, since we cannot open the box once we set up all our hardware connections. 
          </p>
        <h5 class="mt-5 mb-2">Structure</h5>
          <p>
            Due to the need for a modular, independent cooling system, we opted for a design that relies on a closed-loop controller, communicates over Bluetooth, and utilizes the power source already existing in our Fill Station electronics box. As such, we aimed to minimize physical components as much as possible, so we chose fans that accept PWM signals so that we did not have to convert
             PWM signals into high and low signals with an optoisolator and MOSFET like we did in Lab 3. We also use a power supply that connects to a typical outlet, as our Fill Station box uses a power strip connected to a portable battery. The hardware lives on a breadboard, connecting the Pico W to three temperature sensors using I2C and two PWM fans.
          </p>

          <p>
            The iOS app enables two modes of operation: manual and controller. In manual mode, the user can directly set an inverted PWM control signal for the fans to set each fan to whatever fan speed they would like. In controller mode, the user sets a desired temperature, and the closed-loop controller will constantly read actual temperature sensor readings to adjust the fan speed 
            accordingly such that the desired temperature is reached.
          </p>

          <p>
            The closed-loop controller is a proportional (P) controller. We chose not to include integrative (I) and derivative (D) control because we are aiming to adjust fan speed to reach the desired temperature as closely as possible, but oscillations near that temperature due to steady state error do not affect the performance in a significant enough way to require the additional 
            control from I and D gains. The user is able to adjust the P gain value from within the iOS app.
          </p>

          <p>
            The software is implemented using two IRQs to handle PWM control signal updates in each fan and a protothread to continuously collect temperature data samples from all three sensors and execute the P controller in the background. The IRQs are in charge of setting flags that signal when PWM signals can be updated. In the protothread, each temperature sensor is polled for new data. 
            If any sensor returns an invalid status, that sensor is disregarded. All valid sensors are averaged, and this reading is used as the temperature reading for the Fill Station box. Then, based on the flags set by the IRQ handler, if the PWM for a fan is able to be updated, the mode that the fan is in is checked. If the fan is in manual mode, the PWM control signal is set based on 
            the received Bluetooth packet. If the fan is in controller mode, the PWM control signal is set by calculating the error between the averaged temperature value and the desired temperature received from the Bluetooth packet and multiplying this by the P gain value, also received via Bluetooth.
          </p>

        <h5 class="mt-5 mb-2">Hardware/Software Tradeoffs</h5>

        <p>
          The main tradeoff we ran into was with the PWM fans we chose for our project. We chose a fan that accepts PWM signals to simplify the number of hardware components we needed, as this ensured that our physical breadboard setup was minimal and had less room for wiring issues. However, we had some difficulty finding fans that took PWM signals, especially since we were hoping to find a 
          fan that could take 3.3V logic-level signals. Through testing, we found out that the one we chose actually needed a 5V logic level despite the datasheet suggesting it could work with 3.3V, so we added a logic level shifter to our breadboard. The software tradeoff with this PWM fan, we found through testing, was that when powered, this PWM fan cannot completely stop spinning. This 
          means that if our desired temperature is above the current temperature, and we send a PWM signal that would correspond to a fan speed below the fan speed that the PWM fan sets to on power, then the fan cannot decrease its fan speed. In the future, we would hope to select a fan that has the ability to decrease fan speed all the way to zero. 
        </p>

        <h5 class="mt-5 mb-2">Patents/Copyrights/Trademarks</h5>

        <p>
          There are no existing patents, copyrights, or trademarks relevant to our project. All software we referenced and utilized are under open source licenses.
        </p>
        
      </section>

      <section id="hardware" class="section">
        <h2>Hardware Design</h2>
        <p>In order to implement our PID controller, we selected the BME280 Temperature sensor and a PWM Fan as an actuator for cooling. We chose to use three temperature sensors. In case one sensor had invalid readings, an average of the other two could be used. Here, we ensure that our controller is always fed valid temperature readings, operating off of real-time data, rather than past data, even if one of the sensors does not work. Additionally, using three sensors allows us to spread out our sensors across the Fill Station, getting temperature readings from different areas. We chose to utilize two fans, believing that two fans would have enough power to cool the entire Fill Station Electronics Box. However, if we wanted to add additional fans, our current system architecture accounts for that possibility, since we have numerous unused GPIO PWM pins on the PicoW. Below is an image showing our overall system architecture. </p>
        <figure class="text-center">
          <img src="img/ECE4760-FinalProject-Schematic_Final.png" width="400">
          <figcaption class="text-muted mt-2">Hardware Overview - Block Diagram</figcaption>
        </figure>
        <p>The diagram shows that two temperature sensors exist on the I2C0 bus, while one exists on the I2C1. This is because the BME280 can have two different addresses, depending on whether the ADDR pin is pulled high to 3V3 (0x77) or low to GND (0x76). Therefore, two BME280 sensors can exist on the same I2C bus.</p>
        <p>The fans are given power from an external 12 V DC power supply, and are driven by 5V logic level PWM signals. Although the datasheet stated that any signal above 2.8V could actuate the fans, through testing, we realized that a 3.3V PWM signal was too close to the threshold and could not actuate the fans. Since the logic-level output for a Pico is 3V3, we need to level-shift this output. For this, we utilized a 74AHCT125 level shifter/inverter, connecting a 5V DC outlet to the level shifter, 3V3 and GND from the Pico, as well as the PWM signals. This gave us the correct operating conditions. 
        </p>
        <p>To actuate the fans using the Pico, we utilized an interrupt handler, similar to what we did in Lab 3. Here, we utilized a global interrupt handler for both PWM pins, setting flags for each PWM pin. These flags are taken as conditionals in our main protothread, <code>protothread_temp</code> , which is checked after polling for temperature data. </p>
      <p>Below is an image of our final hardware setup, with our three temperature sensors, level shifter and two fans, as well as the PicoW.</p>
      <figure class="text-center">
        <img src="img/hardware.png" width="400">
        <figcaption class="text-muted mt-2">Final Hardware Setup</figcaption>
      </figure>
      </section>

      <section id="software" class="section">
        <h2>Software Design</h2>

         <h5 class="mt-5 mb-2">Pico</h5>
         <h6 class="mt-5 mb-2">Communication with App</h6>
         <p>
          The Active Cooling System has two modes: a manual mode, where the user can set the PWM of the fan, and a controller mode, where a P controller is implemented to automatically control the fans to cool the system to a desired temperature. The desired temperature, as well as the proportional constant, can be set by the user in controller mode. The mode that is set is also a characteristic that is communicated to the Pico. 
         </p>
         <p>In order to implement this structure, we needed to implement GAP Advertisement and GATT Service routines. In the GATT Service routine, we had a .gatt file that initialized the different characteristics as read-only or read and write without response. Any characteristics that the user could control were set as read and write without response, while temperature data was set as read-only. In the GATT header file, we initialized the required handles and communication IDs, as well callback functions for each characteristic. These callback functions were utilized to update temperature sensor readings, as well as handle user-controlled characteristics, handling writes to and from the app. The GAP Advertisement header file handled formatting packets for proper bluetooth transmission. The GAP Advertisement header, as well as the initial formatting for the GATT service routine were taken from Hunter Adams’ example code from the 4760 website.</p>
         <h6  class="mt-5 mb-2">Manual Mode</h6>
         <p>In manual mode, the PWM output is sent from the app to the Pico W. The Pico utilizes the callback function from the service handler in order to change the state of the fans, as well as their state on the app. 
        </p>
        <h6  class="mt-5 mb-2">Controller Mode</h6>
        <p>This mode implements an automated P controller. The user sets a desired temperature value in Celsius. This is then utilized in an error calculation, where the error is the difference between the desired temperature and the measured temperature from the BME280. This measured temperature value is an average of the value measured between the three sensors. If there are invalid sensor readings, the program averages only the valid readings. This way, if one sensor fails, the controller is able to still function. This error is then multiplied by the proportional constant, known as Kp, which converts it to a PWM/duty cycle output. This Kp can be set by the user, but it takes a default value of 100. This value was tuned based on rigorous testing, where higher Kp values ended up saturating our controller to the maximum threshold, and lower Kp values were not cooling the system at an optimal rate. We determined that P-control, without the derivative or integral terms, was sufficient enough for our purposes, since we did not require minimal overshoot and saw a steady state temperature that was close enough to our desired temperature. If the user wants the desired temperature to be reached faster, they can increase the Kp on the app, which automatically sets the Kp value on the PicoW or controller interface. 
        </p>
        <h5 class="mt-5 mb-2">iPhone App</h5>

        <p>
          The app was built in Xcode using Swift, a language created by Apple specifically for development on their platforms. To maximize usability, the frontend was built first so we could see and iterate upon how the data was going to look to the user. I chose to build the frontend using Xcode’s storyboard feature, in which you can lay out all user interface elements visually onto a mock iPhone screen, which eliminates a lot of the pain and tedium of doing it through code only. 
          As each view has its own storyboard, there is one for the thermal view, fan view, and the fan control windows. Each of these views has its own view controller class which manages, via Swift code, how the view responds to user interaction and dynamic data. Here, I store things like backing arrays for the charts of data, or other things like button states. Every iOS app is rigidly structured according to the Model-View-Controller paradigm, so there is not a whole lot of freedom to custom design the software architecture.
        </p>

        <figure class="text-center">
          <img src="img/storyboard.png" width="400" alt="Storyboards">
          <figcaption class="text-muted mt-2">UI design in Xcode</figcaption>
        </figure>
        
        <p>
          For the backend, the majority of the functionality came from implementing the Bluetooth interface. Apple provides many native libraries for interacting with the iPhone’s hardware, such as the Core Bluetooth package for its Bluetooth modem. Using this package, I created a BluetoothManager singleton class which extends from two important Core Bluetooth packages: <code>CBCentralManagerDelegate</code> and <code>CBPeripheralDelegate</code>. <code>CBCentralManagerDelegate</code> allows the app to manage scanning for and connecting to nearby Bluetooth peripherals, while <code>CBPeripheralDelegate</code> handles events related to the connected peripheral, such as discovering services and receiving data from characteristics. 
          To extend from these two classes, you must implement a set of required methods to specify things like which primary service to look for and which characteristics to process. The vast majority of Bluetooth functionality for the app came from implementing these methods. One of these methods, <code>didUpdateValueFor</code>, is called whenever a known characteristic is updated. Thus, if, for example, a new temperature reading on thermometer 1 is received, I update the backing data array for the thermometer 1 chart and refresh the UI for that chart specifically, enabling automatic UI updates as new Bluetooth data comes in.
        </p>

        <p>
          When the app is opened, the BluetoothManager class is initialized and no additional configuration is required from the user.
        </p>
      </section>

      <section id="results" class="section">
        <h2>Results</h2>

      </section>

      <section id="conclusions" class="section">
        <h2>Conclusions</h2>

        <p>
          Overall, we met most of our goals for our active cooling system. Our project enables us to easily and wirelessly monitor the temperature within the fill station electronics box, and maintain controlled temperature regulation through our fans as well. 
          We also learned how to use Bluetooth functionality on both the Pico as well as the iPhone. Due to time and logistical difficulties, one part of our project that we did not get to was integrating the thermal camera. One thing we might’ve done differently was to focus on getting the Bluetooth infrastructure up and running much earlier in the project, as that was the big unknown for all of us going into it.
        </p>
          
        <h5 class="mt-5 mb-2">Conformance to Applicable Standards</h5>
          
        <p>
          Our project conforms to the Bluetooth Low Energy protocol.
        </p>

        <h5 class="mt-5 mb-2">Intellectual Property Considerations</h5>

        <p>
          The app code relied heavily on Apple’s own libraries, as is typical when building for Apple platforms. The Pico code also utilized files and structure from Hunter’s Bluetooth RP2040 Demo, as well as some temperature sensor driver code from Bosch. 
          We don’t see any immediate patent opportunities for our project, as it is highly specialized to our specific use case for our rocket.
        </p>
      
      </section>

      <section id="appendices" class="section">
        <h2>Appendices</h2>

        <h5 class="mt-4 mb-2">Appendix A</h5>

        <p>
          The group approves this report for inclusion on the course website. The group approves the video for inclusion on the course youtube channel.
        </p>

        <h5 class="mt-4 mb-2">Appendix B</h5>

        <p>
          All of our code is on our <a href="https://github.com/cornellrocketryteam/Active-Cooling">GitHub repository</a>.
        </p>
        <p>
          Here is the datasheet for the logic level shifter, the <a href="https://cdn-shop.adafruit.com/product-files/1787/1787AHC125.pdf">74AHCT125 </a>. 
        </p>
      </section>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>

